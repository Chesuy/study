#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>


//************数据的储存************

//一.数据类型
// 
// 1.内置类型：
//            char        字符数据类型        unsigned char     0--255
//                                              signed char  -128--127
//            short       短整形              unsigned short[int]
//                                              signed chort[int]
//            int         整形                unsigned int
//                                              signed int
//            long        长整形              unsigned long[int]
//                                              signed long[int]
//            long long   更长的整形
//            float       单精度浮点数
//            double      双精度浮点数
//
// 2.自定义类型（构造类型）：
//            数组类型
//            结构体类型 struct
//            枚举类型   enum
//            联合类型   union
//
// 3.指针类型：
//            int*
//            char*
//            float*
//            void*
//
//  4.空类型：
//            void--表示空类型（无类型）  通常应用于函数的返回类型、函数的参数、指针类型.
//
// 二.原码、反码、补码
//      
//        计算机中的整型有三种表示方法：即原码、反码、补码，整形无符号的原码、反码和补码相同
//        整形有符号的三种表示方法均有符号位和数值位两部份，符号位都是用0表示正，用1表示负，二数值位三种表示方法各不相同。
//        原码：直接将二进制按照正负数的形式翻译成二进制就可以.
//        反码：将原码的符号位不变，其他位以此按位取反就可以得到了.
//        补码：反码+1就得到补码.
// 
//    对于整形来说：数据存放内存中其实存放的是补码.
//                  在计算机系统中，数值一律用补码来表示和储存.原因在于，使用补码，可以将符号位和数值域统一处理，同时，
//                  加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路.
// 
// 大端（存储）模式：是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
// 小端（存储）模式：是指数据的低位保存在内存的低地址中，而数据的高位，保存在内存的高地址中；
//                   为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应看一个字节，
//                   一个字节为8bit，但是在c语音中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），
//                   另外，对于位数大于8bit的处理器，例如16为或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个
//                   如何将多个字节安排的问题，因此就导致了大端存储模式和小端存储模式.



//写一段代码告诉我们当前机器的字节序是什么
////int check_sys()
////{
////	int a = 1;
////	char* p = &a;
////	if (*p == 1)
////		return 1;
////	else
////		return 0;
////}
//int check_sys()
//{
//	int a = 1;
//	//char* p =(char*)&a;
//	//	return *p;
//	return *(char*)&a;
//}
//int main()
//{
//	int ret = check_sys();//返回1是小端，返回0是大端.
//	if(ret==1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}


//输出什么
//int main()
//{
//	char a = -1;
//	//原码1000 0000 0000 0000 0000 0000 0000 0001
//	//反码1111 1111 1111 1111 1111 1111 1111 1110
//	//补码1111 1111 1111 1111 1111 1111 1111 1111
//  //a=8个字节=1111 1111
//	//有符号数整形提升后1111 1111 1111 1111 1111 1111 1111 1111
//	signed char b = -1;
//	//b=1111 1111
//	//整形提升后1111 1111 1111 1111 1111 1111 1111 1111
//	unsigned char c = -1;
//	//c=1111 1111
//	//无符号数整形提升后0000 0000 0000 0000 0000 0000 1111 1111
//	printf("a=%d ,b=%d ,c=%d", a, b, c);
//	//%d--打印十进制的有符号数字，char要整形提升.
//	return 0;
//}
//
//int main()
//{
//	char a = -128; //1000 0000 直接翻译成-128
//	//原码1000 0000 0000 0000 0000 0000 1000 0000
//	//反码1111 1111 1111 1111 1111 1111 0111 1111
//	//补码1111 1111 1111 1111 1111 1111 1000 0000
//	// a里8个字节1000 0000
//	// char整形提升后1111 1111 1111 1111 1111 1111 1000 0000
//	//
//	printf("%u\n", a);
//	//%u--打印十进制的无符号数字
//	return 0;
//}
//
//int main()
//{
//	int i = -20;
//	//1000 0000 0000 0000 0000 0000 0001 0100   原码
//	//1111 1111 1111 1111 1111 1111 1110 1011   反码
//	//1111 1111 1111 1111 1111 1111 1110 1100   补码
//	unsigned int j = 10;
//	//0000 0000 0000 0000 0000 0000 0000 1010
//	printf("%d\n", i + j);
//	//1111 1111 1111 1111 1111 1111 1111 0110   i+j
//	//1000 0000 0000 0000 0000 0000 0000 1010   原码
//	return 0;
//}
//
//#include <windows.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//		//0-1=-1，因为是无符号整数，-1的补码变成了无符号
//	{
//		printf("%u\n", i);
//		//Sleep(100);//休息100毫秒
//	}
//	return 0;
//}
//int main()
//{
//	char a[1000]; //char a 范围-128--127
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;//这里是-1-- -128 127 --0 -1-- -128 127......
//	}
//	printf("%d", strlen(a));//求字符串长度时遇到‘\0’（ASCII码=0）结束
//	return 0;
//}
//
//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)//i是无符号char类型，i=255+1时，又变成了0
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}


//浮点型在内存中的存储
//
//int main()
//{
//	int n = 9;
//	float* p = (float*)&n;
//	printf("n=%d\n", n);
//	printf("*p=%f\n", *p);
//	*p = 9.0;
//	printf("n=%d\n", n);
//	printf("*p=%f\n", *p);
//	return 0;
//}
//
//根据国际标准IEEE（电气和电子工程协会）754，任意一个二进制浮点数V可以表示成下面的形式：
//               （-1)^S*M*2^E
//                (-1)^S表示符号位，当S=0，V为正数，当S=1，V为负数.  
//                M表示有效数字，大于等于1，小于2.
//                2^E表示指数位
// 例如5.0写成二进制是101.0相当于1.01*2^2,那么按照上面的格式，可以知道S=0,M=1.01,E=2.
// 
// IEEE 754规定：对于32位的浮点数，最高的一位是符号位S，接着的8位是指数E,剩下的23位为有效数字M
//               对于64为的浮点数，最高的一位是符号位S，接着的11位是指数E,剩下的52位为有效数字M
// 
//         在计算机内部保存M时，默认这个数的第一位总是1，因为可以被舍去，只保存后面小数部分.
//         例如保存1.01的时候，只保存01，读取的时候，再把第一位的1加上去.这样做的目的是节省一位有效数字。
// 
//     E的情况比较复杂：首先，E为一个无符号整数，这意味着，如果E为8位，它的取值范围为0-255，如果E为11位，它的取值
//                      范围为0-2047.但是，我们知道，科学计数法中的E是可能出现负数的，所以IEEE 754规定，存入内存时 
//                      E的真实值必须再加上一个中间数，对于8位的W，这个中间数是127，对于11位的E，这个中间数是1023.
//                      比如2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001
//         E全为0：这时，浮点数的指数E等-127（或-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.XXXX的小数.
//                 这样做是为了表示±0，以及接近于0的很小的数字
//         E全为1：这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位S） 

